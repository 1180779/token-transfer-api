package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"errors"
	"sort"
	"token-transfer-api/internal/address"
	"token-transfer-api/internal/db"
	"token-transfer-api/internal/decimal"
	"token-transfer-api/internal/errors/eresolvers"
	"token-transfer-api/internal/graph/model"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

// Transfer is the resolver for the transfer field.
func (r *mutationResolver) Transfer(ctx context.Context, input model.Transfer) (*model.Sender, error) {
	// do not allow negative transfers
	if input.Amount.LessThan(decimal.Zero) {
		return nil, eresolvers.NegativeTransferError
	}

	// only allow int values
	if !input.Amount.IsInteger() {
		return nil, eresolvers.NonIntegerTransferError
	}

	// Handle same address transfer
	if input.FromAddress == input.ToAddress {
		tx := r.Db.Begin()
		if tx.Error != nil {
			return nil, eresolvers.BeginTransactionError
		}

		senderAccount := db.Account{}
		err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
			Where("address = ?", input.FromAddress).
			First(&senderAccount).Error
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				return nil, eresolvers.AddressNotFoundError{Address: input.FromAddress}
			}
			tx.Rollback()
			return nil, eresolvers.AddressRetrievalError{Address: input.FromAddress}
		}

		if senderAccount.Amount.LessThan(input.Amount) {
			tx.Rollback()
			return nil, eresolvers.InsufficientBalanceError
		}

		tx.Commit()
		return &model.Sender{Balance: senderAccount.Amount}, nil
	}

	// handle transfer between two different accounts
	tx := r.Db.Begin()
	if tx.Error != nil {
		return nil, eresolvers.BeginTransactionError
	}

	var addressesToLock []string
	addressesToLock = append(addressesToLock, input.FromAddress.Hex())
	addressesToLock = append(addressesToLock, input.ToAddress.Hex())
	sort.Strings(addressesToLock)

	accounts := make(map[string]*db.Account)
	for _, addr := range addressesToLock {
		account := db.Account{}
		var err error
		if addr == input.FromAddress.Hex() {
			// Sender account must exist, so use First
			err = tx.Clauses(clause.Locking{Strength: "UPDATE"}).
				Where("address = ?", addr).
				First(&account).Error
			if errors.Is(err, gorm.ErrRecordNotFound) {
				tx.Rollback()
				return nil, eresolvers.AddressNotFoundError{Address: input.FromAddress}
			}
		} else {
			err := tx.Clauses(clause.OnConflict{
				Columns:   []clause.Column{{Name: "address"}},
				DoNothing: true,
			}).Create(&db.Account{Address: address.FromHex(addr), Amount: decimal.Zero}).Error
			if err != nil {
				return nil, eresolvers.AddressCreationError{Address: address.FromHex(addr)}
			}

			err = tx.Clauses(clause.Locking{Strength: "UPDATE"}).
				Where(db.Account{Address: address.FromHex(addr)}).
				First(&account).Error
			if err != nil {
				tx.Rollback()
				return nil, err
			}
		}
		accounts[addr] = &account
	}

	senderAccount := accounts[input.FromAddress.Hex()]
	receiverAccount := accounts[input.ToAddress.Hex()]

	if senderAccount.Amount.LessThan(input.Amount) {
		tx.Rollback()
		return nil, eresolvers.InsufficientBalanceError
	}

	senderAccount.Amount = senderAccount.Amount.Sub(input.Amount)
	receiverAccount.Amount = receiverAccount.Amount.Add(input.Amount)

	err := tx.Model(senderAccount).Where("address = ?", senderAccount.Address).Update("Amount", senderAccount.Amount).Error
	if err != nil {
		tx.Rollback()
		return nil, eresolvers.AddressAmountUpdateError{Address: senderAccount.Address}
	}

	err = tx.Model(receiverAccount).
		Where("address = ?", receiverAccount.Address).
		Update("Amount", receiverAccount.Amount).Error
	if err != nil {
		tx.Rollback()
		return nil, eresolvers.AddressAmountUpdateError{Address: receiverAccount.Address}
	}

	err = tx.Commit().Error
	if err != nil {
		return nil, eresolvers.CommitTransactionError
	}

	return &model.Sender{Balance: senderAccount.Amount}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
